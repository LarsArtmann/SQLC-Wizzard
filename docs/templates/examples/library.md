# Library Template Example

This is a library-optimized example suitable for reusable Go libraries, SDKs, and packages.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by LibraryTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
          otp: OTP
```

## Characteristics

- **Database:** PostgreSQL with `pgx/v5` driver
- **Driver:** `pgx/v5` (high performance PostgreSQL)
- **Features:** JSON tags, interface generation, enum validation
- **Output:** `internal/db/` directory
- **Naming:** CamelCase field names with JSON tags

## Usage

### 1. Initialize Library Project

```bash
sqlc-wizard init --template library
```

This generates a library-optimized `sqlc.yaml` configuration.

### 2. Generate Library Code

```bash
sqlc generate
```

This generates Go code in `internal/db/` directory suitable for library use.

### 3. Use Generated Code in Library

#### Library Structure

```
mylibrary/
├── go.mod                    # Go module file
├── go.sum
├── internal/
│   └── db/
│       ├── models.go         # Generated models
│       ├── querier.go        # Generated interface
│       ├── db.sql            # Generated SQL
│       └── queries.go        # Generated queries
└── lib/
    ├── client.go            # Public library API
    ├── config.go            # Configuration
    └── utils.go            # Helper functions
```

#### Public Library API

```go
// lib/client.go - Public library API
package lib

import (
    "context"
    "database/sql"
    "github.com/google/uuid"
    "myproject/internal/db"
)

// Client wraps sqlc generated code with library-specific features
type Client struct {
    db        *sql.DB
    q          Querier
}

// NewClient creates a new library client
func NewClient(db *sql.DB) *Client {
    return &Client{
        db: db,
        q:  db.NewQuerier(db),
    }
}

// NewClientFromDSN creates client from connection string
func NewClientFromDSN(dsn string) (*Client, error) {
    db, err := sql.Open("pgx/v5", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }

    return NewClient(db)
}

// Close closes the database connection
func (c *Client) Close() error {
    if c.db != nil {
        return c.db.Close()
    }
    return nil
}

// User represents a library user model
type User struct {
    ID    uuid.UUID  `json:"id"`
    Name   string     `json:"name"`
    Email  string     `json:"email"`
}

// GetUser retrieves a user by ID
func (c *Client) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    user, err := c.q.User(ctx).GetUser(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("get user: %w", err)
    }

    return user, nil
}

// ListUsers retrieves all users
func (c *Client) ListUsers(ctx context.Context) ([]*User, error) {
    users, err := c.q.User(ctx).ListUsers(ctx)
    if err != nil {
        return nil, fmt.Errorf("list users: %w", err)
    }

    return users, nil
}

// CreateUser creates a new user
func (c *Client) CreateUser(ctx context.Context, name, email string) (uuid.UUID, error) {
    params := internal.CreateUserParams{
        Name:  name,
        Email: email,
    }

    userID, err := c.q.User(ctx).CreateUser(ctx, params)
    if err != nil {
        return uuid.Nil, fmt.Errorf("create user: %w", err)
    }

    return userID, nil
}
```

### 4. Using Library in Application

```go
// main.go - Application using library
package main

import (
    "context"
    "log"
    "os"
    "mylibrary/lib"
)

func main() {
    // Initialize library client
    dbDSN := os.Getenv("DATABASE_URL")
    if dbDSN == "" {
        log.Fatal("DATABASE_URL environment variable is required")
    }

    client, err := lib.NewClientFromDSN(dbDSN)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    ctx := context.Background()

    // Use library API
    userID, err := client.CreateUser(ctx, "John Doe", "john@example.com")
    if err != nil {
        log.Fatal(err)
    }

    // Get user
    user, err := client.GetUser(ctx, userID)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("User: %+v\n", user)

    // List users
    users, err := client.ListUsers(ctx)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Users: %+v\n", users)
}
```

### 5. Mocking for Tests

```go
// lib/mocks_test.go - Library mocks for testing
package lib_test

import (
    "context"
    "github.com/stretchr/testify/mock"
    "github.com/google/uuid"
    "myproject/internal/db"
)

// MockClient implements Client interface with mock database
type MockClient struct {
    db          *mock.Mock
    mockQueries *mockQuerier
}

func NewMockClient() *MockClient {
    mockDB := &mock.Mock{}
    mockQueries := &MockQuerier{
        db: mockDB,
    }

    return &MockClient{
        db:          mockDB,
        mockQueries: mockQueries,
    }
}

// GetUser mocks getting a user
func (m *MockClient) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    user := &User{
        ID:   id,
        Name:  "Mock User",
        Email: "mock@example.com",
    }

    return user, nil
}

// Example test using mock
func TestClient_GetUser(t *testing.T) {
    mockClient := NewMockClient()
    userID := uuid.New()

    // Test with mock
    user, err := mockClient.GetUser(ctx, userID)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if user.ID != userID {
        t.Fatalf("user ID mismatch: got %v, want %v", user.ID, userID)
    }

    assert.Equal(t, "Mock User", user.Name)
    assert.Equal(t, "mock@example.com", user.Email)
}
```

### 6. Interface for Dependency Injection

```go
// lib/client.go - Interface for easier mocking
package lib

// Querier is the interface generated by sqlc
type Querier = internal.Querier

// ClientInterface allows mocking
type ClientInterface interface {
    User(ctx context.Context) Querier
    Close() error
}

// NewClientInterface creates client with interface
func NewClientInterface(db *sql.DB) ClientInterface {
    return &Client{
        db: db,
        q:  db.NewQuerier(db),
    }
}
```

## Example Schema

Create `internal/db/schema/01_users.sql`:

```sql
-- name: User
-- Library-optimized user table with UUID, JSONB
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    metadata JSONB,                         -- Flexible metadata storage
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## Example Query

Create `internal/db/queries/01_users.sql`:

```sql
-- name: GetUser
-- Get user by ID
SELECT * FROM users
WHERE id = $1;

-- name: CreateUser
-- Create a new user
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id;

-- name: ListUsers
-- List all users
SELECT * FROM users
ORDER BY updated_at DESC;
```

## Pros

- ✅ Minimal dependencies (broad compatibility)
- ✅ pgx/v5 driver (high performance)
- ✅ JSON tags (library consumers)
- ✅ Interface generation (mocking & testing)
- ✅ Enum validation (type safety)
- ✅ All enum values generated (flexibility)
- ✅ Pointer types (memory efficiency)
- ✅ Optimized for library usage
- ✅ Easy to mock for unit tests

## Cons

- ❌ No UUID support (libraries may use different ID types)
- ❌ No array support
- ❌ No full-text search
- ❌ No strict validation (flexible for library consumers)
- ❌ No prepared queries (broad compatibility)
- ❌ More complex than simple wrappers

## When to Use

- ✅ Creating reusable Go libraries
- ✅ Building SDKs
- ✅ Developing shared packages
- ✅ Publishing npm/go modules
- ✅ Projects requiring interface flexibility
- ✅ Projects with many consumers
- ✅ Libraries needing broad compatibility

## When NOT to Use

- ❌ Full applications (use Hobby/Microservice templates)
- ❌ Production systems with strict requirements (use Enterprise template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)
- ❌ Analytics platforms (use Analytics template)

## Library Design Patterns

### 1. Database Abstraction

```go
// lib/database.go - Database abstraction
package lib

import (
    "database/sql"
    "github.com/jackc/pgx/v5/stdlib"
)

// Database provides database operations
type Database interface {
    Querier(ctx context.Context) internal.Querier
    Close() error
}

// PostgresDatabase implements Database for PostgreSQL
type PostgresDatabase struct {
    db *sql.DB
}

func NewPostgresDatabase(dsn string) (Database, error) {
    db, err := sql.Open("pgx/v5", dsn)
    if err != nil {
        return nil, err
    }
    return &PostgresDatabase{db: db}
}

func (d *PostgresDatabase) Querier(ctx context.Context) internal.Querier {
    return internal.NewQuerier(d.db)
}

func (d *PostgresDatabase) Close() error {
    return d.db.Close()
}
```

### 2. Configuration Management

```go
// lib/config.go - Library configuration
package lib

type Config struct {
    DatabaseDSN string
    MaxOpenConns int
    MaxIdleConns int
    ConnMaxLifetime time.Duration
}

// DefaultConfig returns library defaults
func DefaultConfig() Config {
    return Config{
        DatabaseDSN:      os.Getenv("DATABASE_URL"),
        MaxOpenConns:     25,
        MaxIdleConns:     5,
        ConnMaxLifetime:   5 * time.Minute,
    }
}
```

### 3. Error Handling

```go
// lib/errors.go - Library error types
package lib

import (
    "errors"
)

var (
    ErrNotFound   = errors.New("not found")
    ErrDuplicate   = errors.New("duplicate")
    ErrValidation = errors.New("validation failed")
)

// WrappedError wraps errors with context
type WrappedError struct {
    Err      error
    Context  string
    Op       string
}

func (e *WrappedError) Unwrap() error {
    return e.Err
}

func (e *WrappedError) Error() string {
    return fmt.Sprintf("%s: %s: %v", e.Op, e.Context, e.Err)
}
```

### 4. Logging

```go
// lib/logger.go - Library logger
package lib

import (
    "log"
    "os"
)

type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    WithError(err error, msg string, fields ...Field)
}

type Field struct {
    Key   string
    Value interface{}
}

// StdLogger implements Logger
type StdLogger struct{}

func (l *StdLogger) Debug(msg string, fields ...Field) {
    log.Printf("[DEBUG] %s %+v\n", msg, fields)
}

func (l *StdLogger) Info(msg string, fields ...Field) {
    log.Printf("[INFO] %s %+v\n", msg, fields)
}

func (l *StdLogger) Error(msg string, fields ...Field) {
    log.Printf("[ERROR] %s %+v\n", msg, fields)
}

func (l *StdLogger) WithError(err error, msg string, fields ...Field) {
    log.Printf("[ERROR] %s %+v %v\n", msg, append(fields, Field{"error": err}))
}
```

## Environment Setup

### Development

```bash
# Local PostgreSQL
export DATABASE_URL="postgres://user:password@localhost:5432/mylib"
```

### Docker Compose

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: mylib
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
    volumes:
      - postgres_data:/var/lib/postgresql/data

  lib:
    build: .
    environment:
      DATABASE_URL: postgres://myuser:mypassword@postgres:5432/mylib
    depends_on:
      - postgres

volumes:
  postgres_data:
```

### Production

```bash
# Production database with connection pooling
export DATABASE_URL="postgres://user:password@prod-db:5432/mylib?pool_max_conns=20&pool_min_conns=5&pool_max_conn_lifetime=1h"
```

## Best Practices

### 1. Versioning

Use semantic versioning for your library:

```go
const Version = "1.0.0"
```

```yaml
# In go.mod
module github.com/your/mylib

go 1.21

require (
    github.com/google/uuid v1.5.0
    github.com/jackc/pgx/v5 v5.5.0
)
```

### 2. Documentation

Document all public APIs:

```go
// GetUser retrieves a user by ID
//
// id is the user's UUID
//
// Returns the user if found, or an error
//
// Example:
//
//   client, _ := lib.NewClientFromDSN(os.Getenv("DATABASE_URL"))
//   defer client.Close()
//
//   user, err := client.GetUser(ctx, userID)
//   if err != nil {
//       log.Fatal(err)
//   }
func (c *Client) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    // Implementation...
}
```

### 3. Testing

#### Unit Tests

```go
// lib/client_test.go
package lib_test

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/google/uuid"
    "myproject/internal/db"
)

func TestClient_GetUser(t *testing.T) {
    // Create mock database
    mockDB := &mock.Mock{}
    mockDB.Match(func(args mock.Arguments) {
        return mock.Arguments{}
    }).Return(&User{
        ID:    uuid.New(),
        Name:   "Test User",
        Email:  "test@example.com",
    }, nil)

    // Create mock querier
    mockQueries := &MockQuerier{
        db: mockDB,
    }

    // Create mock client
    mockClient := &Client{
        db:          mockDB,
        mockQueries: mockQueries,
    }

    ctx := context.Background()

    // Test mock client
    user, err := mockClient.GetUser(ctx, uuid.New())
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    assert.NotNil(t, user)
    assert.Equal(t, "Test User", user.Name)
    assert.Equal(t, "test@example.com", user.Email)
}

func TestClient_GetUser_NotFound(t *testing.T) {
    mockDB := &mock.Mock{}
    mockDB.Match(func(args mock.Arguments) {
        return mock.Arguments{}
    }).Return(nil, sql.ErrNoRows)  // Simulate "not found"

    mockQueries := &MockQuerier{db: mockDB}

    mockClient := &Client{
        db:          mockDB,
        mockQueries: mockQueries,
    }

    ctx := context.Background()

    user, err := mockClient.GetUser(ctx, uuid.New())
    assert.Error(t, err)
    assert.Nil(t, user)
}
```

#### Integration Tests

```go
// lib/client_integration_test.go
package lib_test

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "myproject/internal/db"
)

func TestClient_Integration(t *testing.T) {
    // Use test database
    db, err := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    require.NoError(t, err)
    defer db.Close()

    ctx := context.Background()

    // Test with real database
    client := lib.NewClient(db)
    defer client.Close()

    // Create user
    userID, err := client.CreateUser(ctx, "Integration User", "integration@example.com")
    require.NoError(t, err)

    // Get user
    user, err := client.GetUser(ctx, userID)
    require.NoError(t, err)

    // Assert results
    assert.NotNil(t, user)
    assert.Equal(t, "Integration User", user.Name)
    assert.Equal(t, "integration@example.com", user.Email)
}
```

#### Benchmarks

```go
// lib/client_bench_test.go
package lib_test

import (
    "context"
    "testing"
    "github.com/stretchr/testify/require"
    "myproject/internal/db"
)

func BenchmarkClient_GetUser(b *testing.B) {
    db, err := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    require.NoError(b, err)
    defer db.Close()

    ctx := context.Background()
    client := lib.NewClient(db)

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        userID := uuid.New()
        _, err := client.GetUser(ctx, userID)
        require.NoError(b, err)
    }

    b.StopTimer()
}
```

### 4. Error Handling

Wrap errors with context:

```go
// ✅ GOOD: Wrapped error with context
func (c *Client) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    user, err := c.q.User(ctx).GetUser(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("get user %s: %w", id, err)
    }
    return user, nil
}

// ❌ BAD: Bare error without context
func (c *Client) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    user, err := c.q.User(ctx).GetUser(ctx, id)
    if err != nil {
        return nil, err  // No context, hard to debug
    }
    return user, nil
}
```

### 5. Graceful Shutdown

Implement cleanup on termination:

```go
// lib/client.go - Add Shutdown method
func (c *Client) Shutdown(ctx context.Context) error {
    // Close database connection
    if err := c.Close(); err != nil {
        return fmt.Errorf("close database: %w", err)
    }

    // Wait for in-flight operations
    c.wg.Wait()

    return nil
}

// main.go - Handle shutdown
func main() {
    ctx, cancel := context.WithCancel(context.Background())

    // Setup signal handling
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

    // Setup client
    client, _ := lib.NewClientFromDSN(os.Getenv("DATABASE_URL"))
    defer client.Shutdown(ctx)

    // Run application
    go func() {
        <-sigChan
        cancel()
    }()

    // Your application code here...
}
```

## Publishing Your Library

### 1. Go Module

```yaml
module github.com/your/mylib

go 1.21

require (
    github.com/google/uuid v1.5.0
    github.com/jackc/pgx/v5 v5.5.0
)

replace github.com/your/mylib => ../.
```

### 2. Documentation

Create `README.md`:

```markdown
# My Library

A reusable Go library for user management.

## Features

- UUID-based primary keys
- JSON metadata support
- PostgreSQL with pgx/v5 driver
- Interface generation for mocking
- Type-safe enum validation
- Comprehensive error handling

## Installation

```bash
go get github.com/your/mylib
```

## Quick Start

```go
package main

import (
    "context"
    "log"
    "github.com/your/mylib"
)

func main() {
    // Initialize library client
    client, err := mylib.NewClientFromDSN(os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    ctx := context.Background()

    // Use library
    user, err := client.GetUser(ctx, userID)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("User: %+v\n", user)
}
```

## API Reference

See [API.md](./api.md) for detailed documentation.
```

### 3. CI/CD

Create `.github/workflows/test.yml`:

```yaml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
          POSTGRES_USER: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Install dependencies
        run: go mod download
      - name: Run tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
```

### 4. Release

Create GitHub release:

```bash
# Tag release
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0

# Create GitHub release (uses gh CLI)
gh release create v1.0.0 --generate-notes
```

---

## Summary

The Library template provides:
- ✅ Minimal dependencies (broad compatibility)
- ✅ High-performance PostgreSQL driver (pgx/v5)
- ✅ JSON tags (library consumers)
- ✅ Interface generation (mocking & testing)
- ✅ Enum validation (type safety)
- ✅ Pointer types (memory efficiency)
- ✅ Optimized for library usage
- ✅ Easy to mock for unit tests
- ✅ Comprehensive examples and best practices

Use this template when you need:
- Reusable Go libraries
- SDKs
- Packages
- Projects requiring interface flexibility
- Projects with many consumers
- Libraries needing broad compatibility

**Last Updated:** 2026-02-05
