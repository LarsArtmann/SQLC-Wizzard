# Multi Tenant Template Example

This is a SaaS-optimized example suitable for multi-tenant applications with UUID support and tenant isolation.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by MultiTenantTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: '[]string'
            nullable: true
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
```

## Characteristics

- **Database:** PostgreSQL with `pgx/v5` driver
- **Driver:** `pgx/v5` (high performance)
- **Features:** UUID support (for tenant IDs), JSONB support, Array support
- **Output:** `internal/db/` directory
- **Naming:** CamelCase field names with JSON tags

## Usage

### 1. Initialize Multi-Tenant Project

```bash
sqlc-wizard init --template multi-tenant
```

### 2. Generate Go Code

```bash
sqlc generate
```

### 3. Use Generated Code

```go
package main

import (
    "context"
    "github.com/google/uuid"
    "myproject/internal/db"
)

type Tenant struct {
    ID        uuid.UUID      `json:"id"`
    Name       string         `json:"name"`
    Domain     string         `json:"domain"`
    Metadata   json.RawMessage `json:"metadata"`  // JSONB for tenant settings
    CreatedAt  time.Time       `json:"createdAt"`
}

type User struct {
    ID        uuid.UUID      `json:"id"`
    TenantID   uuid.UUID      `json:"tenantId"`  // Foreign key to tenant
    Email      string         `json:"email"`
    Name       string         `json:"name"`
}

// Generated Query Interface
type Querier interface {
    Tenant(ctx context.Context) *TenantQueries
    User(ctx context.Context) *UserQueries
    CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error)
    GetUserByTenantAndEmail(ctx context.Context, GetUserByTenantAndEmailParams) (*User, error)
    ListUsersByTenant(ctx context.Context, arg ListUsersByTenantParams) ([]*User, error)
    UpdateUser(ctx context.Context, arg UpdateUserParams) error
}

func main() {
    ctx := context.Background()
    db, err := sqlc.New(config, sqlc.NewQuerier(config))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    q := db.User(ctx)
    qTenant := db.Tenant(ctx)

    // Create tenant
    tenantID, err := qTenant.CreateTenant(ctx, "mycompany.com")
    if err != nil {
        log.Fatal(err)
    }

    // Create user with tenant association
    userID, err := q.CreateUser(ctx, CreateUserParams{
        TenantID: tenantID,  // Associate with tenant
        Name:      "John Doe",
        Email:      "john@mycompany.com",
    })
    if err != nil {
        log.Fatal(err)
    }

    // Get user by tenant and email (isolation)
    user, err := q.GetUserByTenantAndEmail(ctx, GetUserByTenantAndEmailParams{
        TenantID: tenantID,
        Email:    "john@mycompany.com",
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("User: %+v\n", user)
}
```

### 4. Example Schema

Create `internal/db/schema/01_tenants.sql`:

```sql
-- name: Tenant
-- Tenant table with UUID primary key
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    domain TEXT NOT NULL UNIQUE,
    metadata JSONB,                          -- Tenant settings
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- name: User
-- User table with tenant_id foreign key
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,  -- Tenant isolation
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for tenant queries
CREATE INDEX idx_users_tenant_email ON users(tenant_id, email);
```

### 5. Example Query

Create `internal/db/queries/01_tenants.sql`:

```sql
-- name: GetTenantByDomain
-- Get tenant by domain
SELECT * FROM tenants
WHERE domain = $1;

-- name: CreateUser
-- Create new tenant
INSERT INTO tenants (name, domain)
VALUES ($1, $2)
RETURNING id;

-- name: GetUserByTenantAndEmail
-- Get user with tenant isolation
SELECT * FROM users
WHERE tenant_id = $1 AND email = $2;

-- name: ListUsersByTenant
-- List all users in tenant
SELECT * FROM users
WHERE tenant_id = $1
ORDER BY created_at DESC;
```

## Pros

- ✅ UUID support (for tenant IDs)
- ✅ JSONB support (for tenant metadata)
- ✅ Array support (for tenant relationships)
- ✅ pgx/v5 driver (high performance PostgreSQL)
- ✅ Prepared queries
- ✅ Interface generation (mocking & testing)
- ✅ Strict validation (tenant data integrity)
- ✅ Tenant isolation (foreign key with CASCADE DELETE)
- ✅ Optimized for SaaS platforms

## Cons

- ❌ No full-text search
- ❌ More complex than single-tenant templates
- ❌ Requires careful data management (multi-tenant isolation)
- ❌ More complex database migrations

## When to Use

- ✅ SaaS platforms
- ✅ Multi-tenant applications
- ✅ B2B systems
- ✅ Applications requiring tenant isolation
- ✅ User-per-organization models
- ✅ Systems with tenant-specific data

## When NOT to Use

- ❌ Single-tenant apps (use Hobby/Microservice templates)
- ❌ Personal projects (use Hobby template)
- ❌ Simple CRUD apps (use Hobby template)
- ❌ Analytics platforms (use Analytics template)

## Environment Setup

Set `DATABASE_URL` environment variable:

```bash
# Production
export DATABASE_URL="postgres://user:password@multi-tenant-db:5432/saas?sslmode=require"

# Using Docker
export DATABASE_URL="postgres://user:password@db:5432/saas?pool_max_conns=50"
```

## Database Migration

From Hobby template:

1. **Change database engine to PostgreSQL**
2. **Add UUID support** (already enabled in Multi-Tenant)
3. **Add JSONB support** (already enabled)
4. **Add array support** (already enabled)
5. **Add tenant tables** (tenants, users with tenant_id foreign key)

## Best Practices

### 1. Tenant Isolation

Always include tenant_id in queries:

```go
// ✅ GOOD: Tenant isolation
users, err := q.ListUsersByTenant(ctx, tenantID)

// ❌ BAD: No tenant filtering (cross-tenant data leak)
users, err := q.ListUsers(ctx)
```

### 2. Cascade Deletes

Use ON DELETE CASCADE for foreign keys:

```sql
-- ✅ GOOD: Automatic cleanup when tenant deleted
ALTER TABLE users ADD CONSTRAINT fk_tenant
FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE;

-- ❌ BAD: Manual cleanup required
ALTER TABLE users ADD CONSTRAINT fk_tenant
FOREIGN KEY (tenant_id) REFERENCES tenants(id);
```

### 3. Tenant-Specific Indexes

Create composite indexes with tenant_id:

```sql
-- ✅ GOOD: Tenant-specific queries are fast
CREATE INDEX idx_users_tenant_email ON users(tenant_id, email);
CREATE INDEX idx_users_tenant_created ON users(tenant_id, created_at);

-- ❌ BAD: Cross-tenant data access risk
CREATE INDEX idx_users_email ON users(email);
```

### 4. Row-Level Security

Enable RLS (Row-Level Security):

```sql
-- Enable RLS for users table
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Create policy: Users can only see their tenant's data
CREATE POLICY tenant_isolation ON users
FOR ALL
USING (tenant_id = (SELECT id FROM tenants WHERE id = current_tenant_id()))
WITH CHECK (true);
```

### 5. Tenant Identification

Pass tenant ID through context:

```go
// ✅ GOOD: Tenant-aware context
func (s *Service) GetUsers(ctx context.Context) ([]*User, error) {
    tenantID := ctx.Value("tenantID").(uuid.UUID)
    return s.queries.ListUsersByTenant(ctx, tenantID)
}

// ❌ BAD: No tenant context (security risk)
func (s *Service) GetUsers(ctx context.Context) ([]*User, error) {
    return s.queries.ListUsers(ctx)
}
```

### 6. Middleware for Tenant Isolation

```go
// middleware.go
package middleware

import (
    "context"
    "net/http"
)

// Tenant middleware extracts tenant ID from request
func TenantMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Extract tenant ID from JWT token or header
        tenantID := extractTenantID(r)

        // Add to context
        ctx := context.WithValue(r.Context(), "tenantID", tenantID)

        // Call next handler
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Example: Use in HTTP handlers
func main() {
    mux := http.NewServeMux()

    // Apply tenant middleware to all routes
    mux.Use(middleware.TenantMiddleware)

    // Routes...
}
```

### 7. Multi-Tenant Database Setup

Use schema-per-tenant or shared schema with tenant_id:

**Option A: Shared Schema** (current Multi-Tenant template)
```sql
-- Single database with tenant_id foreign keys
CREATE TABLE users (
    id UUID PRIMARY KEY,
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    -- ...
);
```

**Option B: Schema-per-Tenant** (for high isolation)
```sql
-- Each tenant gets its own schema
CREATE SCHEMA tenant_1;
CREATE TABLE tenant_1.users (...);

CREATE SCHEMA tenant_2;
CREATE TABLE tenant_2.users (...);

-- Select correct schema at runtime
SET search_path TO tenant_1;
```

### 8. Tenant Migration

Migrate single-tenant to multi-tenant:

```sql
-- Step 1: Add tenants table
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    -- ...
);

-- Step 2: Add tenant_id to users
ALTER TABLE users ADD COLUMN tenant_id UUID REFERENCES tenants(id);

-- Step 3: Migrate existing data to default tenant
INSERT INTO tenants (id, name) VALUES (gen_random_uuid(), 'Default Tenant');
UPDATE users SET tenant_id = (SELECT id FROM tenants WHERE name = 'Default Tenant') WHERE tenant_id IS NULL;
```

## Security Considerations

### 1. Tenant Data Isolation

Ensure tenants cannot access each other's data:

```sql
-- ✅ Row-Level Security policy
CREATE POLICY tenant_isolation ON users
FOR SELECT
USING (tenant_id = (SELECT id FROM tenants WHERE id = current_tenant_id()));

-- ✅ Always filter by tenant_id in application layer
SELECT * FROM users WHERE tenant_id = $tenantID;
```

### 2. Tenant Authentication

Verify tenant belongs to user:

```go
func (s *AuthService) VerifyTenant(ctx context.Context, userID, tenantID uuid.UUID) error {
    // Check if user belongs to tenant
    belongs, err := s.queries.GetUserTenant(ctx, GetUserTenantParams{
        UserID:   userID,
        TenantID: tenantID,
    })
    if err != nil {
        return fmt.Errorf("user not in tenant")
    }

    if !belongs {
        return fmt.Errorf("unauthorized: user not in tenant")
    }

    return nil
}
```

### 3. Resource Quotas

Enforce tenant resource limits:

```sql
-- Track tenant resource usage
CREATE TABLE tenant_usage (
    tenant_id UUID REFERENCES tenants(id),
    resource_type TEXT NOT NULL,  -- 'users', 'storage', 'requests'
    amount INTEGER NOT NULL,
    period_start TIMESTAMP NOT NULL,
    period_end TIMESTAMP NOT NULL,
    PRIMARY KEY (tenant_id, resource_type, period_start)
);

-- Example: Limit user count per tenant
INSERT INTO tenant_usage (tenant_id, resource_type, amount, period_start, period_end)
SELECT id, (SELECT COUNT(*) FROM users WHERE tenant_id = t.id) as amount, NOW(), NOW() + INTERVAL '1 month'
FROM tenants t;
```

### 4. Tenant Deletion

Handle tenant deletion with CASCADE:

```go
func (s *TenantService) DeleteTenant(ctx context.Context, tenantID uuid.UUID) error {
    // Start transaction
    tx, err := s.db.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Delete all tenant data (CASCADE handles this in schema)
    _, err = s.queries.DeleteTenant(ctx, tenantID)
    if err != nil {
        return err
    }

    // Commit transaction
    return tx.Commit()
}
```

---

**Last Updated:** 2026-02-05
