# Microservice Template Example

This is an API-optimized example suitable for microservices and REST backends.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by MicroserviceTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: false
        emit_params_struct_pointers: false
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
```

## Characteristics

- **Database:** PostgreSQL (high-performance pgx/v5 driver)
- **Driver:** pgx/v5 (prepared queries, better performance)
- **Features:** JSON tags, prepared queries, interface generation
- **Output:** `internal/db/` directory
- **Naming:** CamelCase field names (JSON API standard)

## Usage

### 1. Initialize Project

```bash
sqlc-wizard init --template microservice
```

This generates the `sqlc.yaml` configuration with MicroserviceTemplate defaults.

### 2. Generate Go Code

```bash
sqlc generate
```

This generates Go code in `internal/db/` directory.

### 3. Use Generated Code

```go
package main

import (
    "context"
    "myproject/internal/db"
)

type User struct {
    ID        uuid.UUID      `json:"id"`
    Name       string         `json:"name"`
    Email      string         `json:"email"`
    CreatedAt  time.Time       `json:"createdAt"`
}

// Generated Query Interface
type Querier interface {
    User(ctx context.Context) *UserQueries
    CreateUser(ctx context.Context, arg string) (int64, error)
    GetUserByEmail(ctx context.Context, email string) (*User, error)
    ListUsers(ctx context.Context) ([]*User, error)
}

func main() {
    db, err := sqlc.New(config, sqlc.NewQuerier(config))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    q := db.User(ctx)

    // Insert user
    id, err := q.CreateUser(ctx, "user@example.com")
    if err != nil {
        log.Fatal(err)
    }

    // Get user by email
    user, err := q.GetUserByEmail(ctx, "user@example.com")
    if err != nil {
        log.Fatal(err)
    }

    // List users
    users, err := q.ListUsers(ctx)
    if err != nil {
        log.Fatal(err)
    }
}
```

### 4. Example Schema

Create `internal/db/schema/01_users.sql`:

```sql
-- name: User
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 5. Example Query

Create `internal/db/queries/01_users.sql`:

```sql
-- name: CreateUser
-- Insert a new user
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id;

-- name: GetUserByEmail
-- Get user by email
SELECT * FROM users
WHERE email = $1;
```

## Pros

- ✅ High-performance PostgreSQL driver (pgx/v5)
- ✅ Prepared queries (security & performance)
- ✅ JSON tags for API responses
- ✅ Interface generation (mocking & testing)
- ✅ CamelCase field names (JSON API standard)
- ✅ Production-ready configuration

## Cons

- ❌ No UUID support (need for distributed systems)
- ❌ No array support (many-to-many relationships)
- ❌ No full-text search

## When to Use

- ✅ Building REST APIs
- ✅ Building GraphQL APIs
- ✅ Microservice architecture
- ✅ API-first development
- ✅ Production APIs
- ✅ Services with JSON serialization requirements

## When NOT to Use

- ❌ Analytics platforms (use Analytics template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)
- ❌ Hobby projects (use Hobby template)

## Environment Setup

Set `DATABASE_URL` environment variable:

```bash
export DATABASE_URL="postgres://user:password@localhost:5432/mydb?sslmode=disable"
```

Or in production:

```bash
# In Docker
export DATABASE_URL="postgres://user:password@db:5432/mydb"

# In Kubernetes (from secret)
export DATABASE_URL="${DATABASE_SECRET}"
```

## Database Migration

If migrating from Hobby template:

1. **Change database engine:**

```yaml
# From
database:
  uri: file:dev.db

# To
database:
  uri: ${DATABASE_URL}
```

2. **Enable features:**

```yaml
# Add JSON support
data.Database.UseJSON = true
```

## Best Practices

1. **Use prepared queries** → They're more secure and performant
2. **Leverage interfaces** → They make testing and mocking easier
3. **Environment variables** → Never hardcode database credentials
4. **Use UUID for primary keys** → Better for distributed systems (add: `data.Database.UseUUIDs = true`)
5. **JSON tags** → Enable for API responses
6. **CamelCase naming** → Follow API conventions

## Testing

Use interface generation for easy mocking:

```go
func TestHandler_GetUser(t *testing.T) {
    mockQueries := &MockQuerier{
        GetUserByEmail: func(ctx context.Context, email string) (*User, error) {
            return &User{
                ID:        uuid.New(),
                Name:       "Test User",
                Email:      "test@example.com",
            }, nil
        },
    }

    handler := NewHandler(mockQueries)
    user, err := handler.GetUser("test@example.com")
    // Assert...
}
```

## Deployment

### Docker Compose

```yaml
version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
    volumes:
      - postgres_data:/var/lib/postgresql/data

  app:
    build: .
    environment:
      DATABASE_URL: postgres://myuser:mypassword@postgres:5432/mydb
    depends_on:
      - postgres

volumes:
  postgres_data:
```

## Performance Tips

1. **Use connection pooling** → pgx/v5 handles this automatically
2. **Prepared queries** → Already enabled (performance)
3. **Batch operations** → Use WHERE IN for multiple lookups
4. **Index optimization** → Add indexes for query fields
5. **Query result limits** → Use pagination for large datasets

## Security Considerations

1. **Prepared queries** → Prevent SQL injection
2. **Environment variables** → Never commit database URLs
3. **Use UUIDs** → Prevent predictable IDs (enable: `data.Database.UseUUIDs = true`)
4. **Strict mode** → Enable in production (add: `data.Validation.StrictFunctions = true`)
