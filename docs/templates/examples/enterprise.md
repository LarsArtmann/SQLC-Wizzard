# Enterprise Template Example

This is a production-ready example suitable for enterprise applications with comprehensive validation and advanced features.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by EnterpriseTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: '[]string'
            nullable: true
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
          otp: OTP
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
          - name: require-where
            rule: WHERE clause is required
          - name: no-drop-table
            rule: DROP TABLE is not allowed
          - name: no-truncate
            rule: TRUNCATE TABLE is not allowed
          - name: require-limit
            rule: LIMIT clause is required
```

## Characteristics

- **Database:** PostgreSQL with `pgx/v5` driver (high performance)
- **Driver:** `pgx/v5` with prepared queries
- **Features:** ALL features enabled (UUID, JSONB, Arrays, Full-Text)
- **Validation:** STRICT mode (all safety rules enabled)
- **Output:** `internal/db/` directory
- **Naming:** CamelCase with JSON tags
- **Pointers:** All result and param structs use pointers

## Usage

### 1. Initialize Project

```bash
sqlc-wizard init --template enterprise
```

This generates a production-ready `sqlc.yaml` configuration.

### 2. Generate Go Code

```bash
sqlc generate
```

This generates Go code in `internal/db/` directory with all enterprise features.

### 3. Use Generated Code

```go
package main

import (
    "context"
    "fmt"
    "myproject/internal/db"
    "github.com/google/uuid"
)

type User struct {
    ID        uuid.UUID      `json:"id"`
    Name       string         `json:"name"`
    Email      string         `json:"email"`
    Metadata   json.RawMessage `json:"metadata"`  // JSONB support
    Tags       []string        `json:"tags"`       // Array support
    CreatedAt  time.Time       `json:"createdAt"`
    UpdatedAt  time.Time       `json:"updatedAt"`
}

// Generated Query Interface
type Querier interface {
    User(ctx context.Context) *UserQueries
    CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error)
    GetUser(ctx context.Context, id uuid.UUID) (*User, error)
    GetUserByEmail(ctx context.Context, email string) (*User, error)
    ListUsers(ctx context.Context, arg ListUsersParams) ([]*User, error)
    UpdateUser(ctx context.Context, arg UpdateUserParams) error
    DeleteUser(ctx context.Context, id uuid.UUID) error
    SearchUsers(ctx context.Context, arg SearchUsersParams) ([]*User, error)
}

func main() {
    // Connect to database
    ctx := context.Background()
    db, err := sqlc.New(config, sqlc.NewQuerier(config))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    q := db.User(ctx)

    // Create user with UUID
    userID, err := q.CreateUser(ctx, CreateUserParams{
        Name:  "John Doe",
        Email: "john@example.com",
    })
    if err != nil {
        log.Fatal(err)
    }

    // Get user by ID
    user, err := q.GetUser(ctx, userID)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("User: %+v\n", user)
}
```

### 4. Example Schema

Create `internal/db/schema/01_users.sql`:

```sql
-- name: User
-- Enterprise-grade user table with UUID, JSONB, arrays
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    metadata JSONB,                          -- Document storage
    tags TEXT[] NOT NULL,                      -- Array support
    full_text_search TSVECTOR,                 -- Full-text search
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for full-text search
CREATE INDEX idx_users_full_text ON users USING GIN (full_text_search);
```

### 5. Example Queries

Create `internal/db/queries/01_users.sql`:

```sql
-- name: CreateUser
-- Create a new user
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id;

-- name: GetUser
-- Get user by ID
SELECT * FROM users
WHERE id = $1;

-- name: GetUserByEmail
-- Get user by email
SELECT * FROM users
WHERE email = $1;

-- name: ListUsers
-- List all users with limit
SELECT * FROM users
ORDER BY updated_at DESC
LIMIT ALL($1) OFFSET $2;

-- name: UpdateUser
-- Update user
UPDATE users
SET name = $1, updated_at = NOW()
WHERE id = $2;

-- name: DeleteUser
-- Delete user
DELETE FROM users
WHERE id = $1;

-- name: SearchUsers
-- Full-text search on users
SELECT *, ts_rank(full_text_search, websearch_to_tsquery('english', $1)) AS rank
FROM users
WHERE full_text_search @@ websearch_to_tsquery('english', $1)
ORDER BY rank DESC
LIMIT ALL($2) OFFSET $3;
```

## Pros

- ✅ ALL features enabled (UUID, JSONB, Arrays, Full-Text)
- ✅ High-performance PostgreSQL driver (pgx/v5)
- ✅ Strict validation (data integrity)
- ✅ All safety rules (no bad queries)
- ✅ Prepared queries (security & performance)
- ✅ Interface generation (mocking & testing)
- ✅ Pointer types (memory efficiency)
- ✅ Production-ready configuration
- ✅ Comprehensive error handling

## Cons

- ❌ Most complex generated code
- ❌ Longest build times
- ❌ Most dependencies (uuid, pgx)
- ❌ Overkill for simple projects
- ❌ More complex than needed for basic apps
- ❌ Requires PostgreSQL (cannot use SQLite)

## When to Use

- ✅ Production systems
- ✅ Enterprise applications
- ✅ Critical infrastructure
- ✅ Systems with strict data integrity requirements
- ✅ Compliance-heavy environments (GDPR, HIPAA)
- ✅ High-traffic applications
- ✅ Complex data relationships (arrays, many-to-many)
- ✅ Applications requiring full-text search
- ✅ Systems needing data safety (all safety rules)

## When NOT to Use

- ❌ Personal projects (use Hobby template)
- ❌ Simple prototypes (use Hobby template)
- ❌ Learning sqlc (use Hobby/Testing templates)
- ❌ Small applications (use Hobby template)
- ❌ Analytics platforms (use Analytics template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)

## Environment Setup

### Production

Set `DATABASE_URL` environment variable:

```bash
# PostgreSQL connection string
export DATABASE_URL="postgres://user:password@prod-db:5432/enterprise?sslmode=require"

# Using connection pool
export DATABASE_URL="postgres://user:password@prod-db:5432/enterprise?pool_max_conns=20&pool_min_conns=5&pool_max_conn_lifetime=1h"
```

### Using Connection Pooling

```bash
# With pgBouncer
export DATABASE_URL="postgres://user:password@pgbouncer:6432/enterprise?sslmode=require"
```

### Using Docker Compose

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: enterprise
      POSTGRES_USER: enterprise_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./secrets:/run/secrets:ro
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres_user -d enterprise"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    environment:
      DATABASE_URL: postgres://enterprise_user:${POSTGRES_PASSWORD}@postgres:5432/enterprise?sslmode=require
    depends_on:
      postgres:
        condition: service_healthy

volumes:
  postgres_data:
  secrets:
```

### Using Kubernetes

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-config
data:
  DATABASE_URL: "postgres://user:password@postgres-service:5432/enterprise?sslmode=require"
---
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
type: Opaque
stringData:
  username: enterprise_user
  password: ${POSTGRES_PASSWORD}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: enterprise-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: enterprise-app
  template:
    metadata:
      labels:
        app: enterprise-app
    spec:
      containers:
      - name: app
        image: enterprise:latest
        env:
          - name: DATABASE_URL
            valueFrom:
              secretKeyRef:
                name: database-credentials
                key: username
        resources:
          limits:
            memory: "512Mi"
            cpu: "500m"
          requests:
            memory: "256Mi"
            cpu: "250m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      restartPolicy: Always
```

## Database Migration

### From Hobby to Enterprise

1. **Change database engine:**
```yaml
# From
database:
  uri: file:dev.db

# To
database:
  uri: ${DATABASE_URL}
```

2. **Enable ALL enterprise features:**
```yaml
# UUID support
data.Database.UseUUIDs = true

# JSONB support
data.Database.UseJSON = true

# Array support
data.Database.UseArrays = true

# Full-text search
data.Database.UseFullText = true
```

3. **Enable strict validation:**
```yaml
# Strict function checks
data.Validation.StrictFunctions = true

# Strict ORDER BY
data.Validation.StrictOrderBy = true

# Enable all safety rules
data.Validation.SafetyRules.NoSelectStar = true
data.Validation.SafetyRules.RequireWhere = true
data.Validation.SafetyRules.NoDropTable = true
data.Validation.SafetyRules.NoTruncate = true
data.Validation.SafetyRules.RequireLimit = true
```

### From Microservice to Enterprise

1. **Add missing features:**
```yaml
# Add arrays
data.Database.UseArrays = true

# Add full-text search
data.Database.UseFullText = true
```

2. **Enable strict validation:**
```yaml
data.Validation.StrictFunctions = true
data.Validation.StrictOrderBy = true
```

3. **Enable all safety rules:**
```yaml
data.Validation.SafetyRules.NoSelectStar = true
# etc...
```

## Performance Tips

### 1. Use Connection Pooling

pgx/v5 handles connection pooling automatically, but you can tune:

```go
cfg, err := pgxpool.ParseConfig(os.Getenv("DATABASE_URL"))
if err != nil {
    log.Fatal(err)
}
cfg.MaxConns = 25              // Maximum connections
cfg.MinConns = 5               // Minimum connections
cfg.MaxConnLifetime = 1 * time.Hour  // Connection lifetime
cfg.MaxConnIdleTime = 5 * time.Minute  // Idle connection timeout
cfg.HealthCheckPeriod = 1 * time.Minute // Health check interval
```

### 2. Use Prepared Queries

Already enabled in Enterprise template (`emit_prepared_queries: true`).

```go
// Use prepared query context
ctx := context.Background()

// Prepared query (already compiled by sqlc)
users, err := q.ListUsers(ctx)

// More efficient than raw queries
```

### 3. Index Optimization

Create appropriate indexes for your queries:

```sql
-- Primary key (already indexed)
CREATE UNIQUE INDEX idx_users_email ON users(email);

-- For full-text search
CREATE INDEX idx_users_full_text ON users USING GIN (full_text_search);

-- For array queries
CREATE INDEX idx_users_tags ON users USING GIN (tags);

-- Composite index for common queries
CREATE INDEX idx_users_email_created ON users(email, created_at);
```

### 4. Query Optimization

Use proper query patterns:

```sql
-- GOOD: Use parameterized queries
SELECT * FROM users WHERE id = $1;

-- BAD: String concatenation (SQL injection risk)
SELECT * FROM users WHERE id = ' || user_id;

-- GOOD: Use LIMIT for pagination
SELECT * FROM users ORDER BY created_at DESC LIMIT 10 OFFSET 20;

-- BAD: Fetch all then filter (memory issue)
SELECT * FROM users ORDER BY created_at;
```

### 5. Batch Operations

Use batch inserts/updates:

```go
// GOOD: Batch insert
_, err := q.CreateUsers(ctx, users)

// GOOD: Batch update
_, err := q.UpdateUsers(ctx, updates)

// AVOID: N+1 queries in loop
for _, user := range users {
    _, err := q.CreateUser(ctx, user)  // BAD
}
```

## Security Considerations

### 1. Prepared Queries

Enterprise template uses prepared queries by default - they prevent SQL injection:

```go
// ✅ SAFE: Prepared query
users, err := q.ListUsers(ctx)

// ❌ UNSAFE: Raw SQL query
query := fmt.Sprintf("SELECT * FROM users WHERE name = '%s'", name)
rows, err := db.Query(query)
```

### 2. Environment Variables

Never commit database URLs to code:

```go
// ✅ SAFE: Environment variable
dbURL := os.Getenv("DATABASE_URL")

// ❌ UNSAFE: Hardcoded credentials
dbURL := "postgres://user:password@localhost:5432/mydb"
```

### 3. UUID Primary Keys

Enterprise template uses UUIDs for primary keys - prevents enumeration attacks:

```sql
-- ✅ SAFE: UUID primary key
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    -- ...
);

-- ❌ UNSAFE: Sequential integer primary keys
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- Predictable IDs
    -- ...
);
```

### 4. Strict Validation

All safety rules enabled by default:

```yaml
rules:
  - name: no-select-star
    rule: SELECT * is not allowed
  - name: require-where
    rule: WHERE clause is required
  - name: no-drop-table
    rule: DROP TABLE is not allowed
  - name: no-truncate
    rule: TRUNCATE TABLE is not allowed
  - name: require-limit
    rule: LIMIT clause is required
```

## Testing

### Unit Tests with Interfaces

```go
func TestUserService_CreateUser(t *testing.T) {
    // Create mock queries
    mockQueries := &MockQuerier{
        CreateUser: func(ctx context.Context, params CreateUserParams) (uuid.UUID, error) {
            userID := uuid.New()
            return userID, nil
        },
    }

    // Use mock in test
    service := NewUserService(mockQueries)

    // Test
    id, err := service.CreateUser(ctx, "test@example.com")
    assert.NoError(t, err)
    assert.NotEqual(t, uuid.Nil, id)
}
```

### Integration Tests

```go
func TestUserService_E2E(t *testing.T) {
    // Use test database
    ctx := context.Background()
    db, _ := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    defer db.Close()

    // Test real query
    q := db.User(ctx)
    users, err := q.ListUsers(ctx)
    assert.NoError(t, err)
    assert.Greater(t, len(users), 0)
}
```

### Load Testing

```bash
# Run tests with pgbench
pgbench -h localhost -p 5432 -U postgres -d enterprise -c 10 -j 4

# Or use Go benchmarks
go test -bench=. -benchmem
```

## Monitoring

### 1. Application Metrics

```go
import (
    "github.com/prometheus/client_golang/prometheus"
)

var (
    dbQueryDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "db_query_duration_seconds",
            Help: "Database query duration",
            Buckets: prometheus.DefBuckets,
        },
    )
)

// Wrap queries with metrics
func (q *UserQueries) WithMetrics() *UserQueries {
    return &UserMetrics{q}
}

func (qm *UserMetrics) ListUsers(ctx context.Context) ([]*User, error) {
    start := time.Now()
    users, err := qm.ListUsers(ctx)
    duration := time.Since(start).Seconds()
    dbQueryDuration.Observe(duration)
    return users, err
}
```

### 2. Database Metrics

```bash
# Monitor PostgreSQL with pg_stat_statements
ALTER DATABASE enterprise SET log_min_duration_statement = 0;
ALTER DATABASE enterprise SET log_statement = 'all';

# Monitor slow queries
SELECT query, mean_exec_time, calls, total_exec_time, rows
FROM pg_stat_statements
WHERE mean_exec_time > 1000  -- Queries over 1 second
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### 3. Connection Pool Metrics

```go
// Monitor pool stats
stats := db.Stat()
fmt.Printf("AcquireCount: %d\n", stats.AcquireCount())
fmt.Printf("AcquireDuration: %v\n", stats.AcquireDuration())
fmt.Printf("EmptyAcquireCount: %d\n", stats.EmptyAcquireCount())
fmt.Printf("MaxOpenConnections: %d\n", stats.MaxOpenConnections())
```

## Best Practices

### 1. Use Transactions

```go
func (s *UserService) UpdateUserMetadata(ctx context.Context, userID uuid.UUID, metadata json.RawMessage) error {
    // Start transaction
    tx, err := s.db.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Execute multiple queries in transaction
    q := s.db.User(tx)
    if err := q.UpdateUser(ctx, userID); err != nil {
        return err
    }
    if err := q.UpdateUserTags(ctx, userID, tags); err != nil {
        return err
    }

    // Commit transaction
    return tx.Commit()
}
```

### 2. Handle Timeouts

```go
func (s *UserService) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
    // Set timeout
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    // Query with timeout
    user, err := s.queries.GetUser(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("get user: %w", err)
    }

    return user, nil
}
```

### 3. Use Connection Properly

```go
func (s *UserService) ProcessUser(ctx context.Context, userID uuid.UUID) error {
    // Get connection (not create new)
    conn, err := s.db.Conn(ctx)
    if err != nil {
        return fmt.Errorf("get connection: %w", err)
    }
    defer conn.Close()

    // Process user
    q := s.queries.User(ctx)
    user, err := q.GetUser(ctx, userID)
    if err != nil {
        return fmt.Errorf("process user: %w", err)
    }

    return nil
}
```

### 4. Error Handling

```go
func (s *UserService) CreateUser(ctx context.Context, name, email string) (uuid.UUID, error) {
    // Validate input
    if name == "" {
        return uuid.Nil, fmt.Errorf("name cannot be empty")
    }
    if email == "" || !strings.Contains(email, "@") {
        return uuid.Nil, fmt.Errorf("invalid email: %s", email)
    }

    // Try to create user
    userID, err := s.queries.CreateUser(ctx, CreateUserParams{
        Name:  name,
        Email: email,
    })

    // Wrap error with context
    if err != nil {
        return uuid.Nil, fmt.Errorf("create user %s %s: %w", name, email, err)
    }

    return userID, nil
}
```

### 5. Resource Cleanup

```go
func (s *UserService) BatchImportUsers(ctx context.Context, users []ImportUser) error {
    // Process in batches
    const batchSize = 100
    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }
        batch := users[i:end]

        // Use transaction for batch
        if err := s.importBatch(ctx, batch); err != nil {
            return fmt.Errorf("import batch %d-%d: %w", i, end, err)
        }
    }

    return nil
}
```

## Migration to Production

### 1. Pre-Production Checklist

- [ ] All tests passing (unit + integration)
- [ ] Performance benchmarks meet SLA
- [ ] Database indexes created and optimized
- [ ] Connection pooling configured
- [ ] Error handling and logging in place
- [ ] Monitoring and metrics configured
- [ ] Security review completed
- [ ] Load testing performed
- [ ] Failover and redundancy configured
- [ ] Backup and recovery procedures tested
- [ ] Documentation complete
- [ ] Team trained on operations

### 2. Production Configuration

```yaml
# Production-ready config
version: "2"
sql:
  - engine: postgresql
    database:
      uri: ${DATABASE_URL}  # Production database URL
      managed: true  # Enable managed mode
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        # Production code generation settings
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
```

### 3. Rollback Plan

```sql
-- Migration rollback procedure
BEGIN;

-- Create new table
CREATE TABLE users_new (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    -- ...
);

-- Copy data (in batches to avoid locks)
INSERT INTO users_new (id, name, email)
SELECT id, name, email FROM users;

-- Rename tables (atomic)
ALTER TABLE users RENAME TO users_old;
ALTER TABLE users_new RENAME TO users;

-- Verify migration
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM users WHERE id IS NULL) THEN
        RAISE EXCEPTION 'Migration failed: NULL IDs found';
    END IF;
END $$;

-- If successful, drop old table
DROP TABLE users_old;

COMMIT;

-- If failed, rollback
-- DROP TABLE users_new;
-- ALTER TABLE users_old RENAME TO users;
```

---

## Summary

The Enterprise template provides:
- ✅ Production-ready configuration
- ✅ ALL features enabled (UUID, JSONB, Arrays, Full-Text)
- ✅ Strict validation and all safety rules
- ✅ High-performance PostgreSQL driver (pgx/v5)
- ✅ Comprehensive documentation and examples
- ✅ Best practices for production systems

Use this template when you need:
- Enterprise-grade data integrity
- Comprehensive feature set
- Strict validation rules
- Production-ready security
- High performance and scalability

---

**Last Updated:** 2026-02-05
