# Testing Template Example

This is a minimal example suitable for test fixtures and mock data.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by TestingTemplate
version: "2"
sql:
  - engine: sqlite
    queries: testdata/db/queries
    schema: testdata/db/schema
    database:
      uri: file:testdata/test.db
    strict_function_checks: false
    strict_order_by: false
    gen:
      go:
        package: testdata/db
        out: testdata/db
        sql_package: database/sql
        emit_json_tags: false
        emit_prepared_queries: false
        emit_interface: false
        emit_empty_slices: true
        emit_result_struct_pointers: false
        emit_params_struct_pointers: false
        json_tags_case_style: snake
```

## Characteristics

- **Database:** SQLite (file-based, no database server needed)
- **Driver:** `database/sql` (standard Go SQL package)
- **Features:** Minimal dependencies, simple setup
- **Output:** `testdata/db/` directory (test paths)
- **Validation:** Relaxed (no strict checks)

## Usage

### 1. Initialize Test Project

```bash
sqlc-wizard init --template testing
```

This generates → `testdata/db/` directory structure.

### 2. Generate Test Code

```bash
sqlc generate
```

This generates → `testdata/db/models.go` and `testdata/db/querier.go`

### 3. Use Generated Code in Tests

```go
// test/models_test.go
package models_test

import (
    "testing"
    "myproject/testdata/db"
)

func TestUserModel(t *testing.T) {
    user := User{
        Name: "Test User",
        Email: "test@example.com",
    }

    assert.Equal(t, "Test User", user.Name)
    assert.Equal(t, "test@example.com", user.Email)
}
```

### 4. Create Test Schema

Create `testdata/db/schema/01_users.sql`:

```sql
-- Simple user table for testing
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5. Create Test Queries

Create `testdata/db/queries/01_users.sql`:

```sql
-- name: GetTestUser
-- Get test user
SELECT * FROM users
WHERE id = ?;

-- name: ListTestUsers
-- List all test users
SELECT * FROM users;
```

### 6. Create Test Fixtures

Create `testdata/fixtures/users.sql`:

```sql
-- Test fixture data
INSERT INTO users (name, email) VALUES
('Test User 1', 'test1@example.com'),
('Test User 2', 'test2@example.com'),
('Test User 3', 'test3@example.com');
```

Load fixtures:

```bash
# Load test fixtures
sqlite3 testdata/test.db < testdata/fixtures/users.sql

# Or in Go
db, err := sqlc.New(config)
if err != nil {
    log.Fatal(err)
}
defer db.Close()

// Run queries...
```

### 7. Mocking Generated Code

```go
// mock_test.go
package db_test

import (
    "testing"
    "github.com/stretchr/testify/mock"
)

// Mock the generated Querier interface
type MockQuerier struct {
    mock.Mock
}

func (m *MockQuerier) User(ctx context.Context) *UserQueries {
    return &UserQueries{mock: &m.Mock}
}

func TestUserService_WithMock(t *testing.T) {
    mockDB := &MockQuerier{}
    mockDB.Mock.On("User").Return(&UserQueries{})

    service := NewUserService(mockDB)

    // Test service behavior with mock...
}
```

### 8. Integration Tests

```go
// integration_test.go
package integration_test

import (
    "context"
    "testing"
    "os"
    "myproject/testdata/db"
)

func TestDatabaseConnection(t *testing.T) {
    // Use test database
    ctx := context.Background()
    db, err := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    if err != nil {
        t.Fatalf("Failed to connect to test database: %v", err)
    }
    defer db.Close()

    q := db.User(ctx)

    // Test query
    users, err := q.ListUsers(ctx)
    if err != nil {
        t.Fatalf("Failed to list users: %v", err)
    }

    // Assert results
    assert.NotNil(t, users)
    assert.GreaterOrEqual(t, 0, len(users))
}

func TestTransactions(t *testing.T) {
    ctx := context.Background()
    db, err := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    if err != nil {
        t.Fatalf("Failed to connect: %v", err)
    }
    defer db.Close()

    // Test transaction
    tx, err := db.Begin(ctx)
    if err != nil {
        t.Fatalf("Failed to begin transaction: %v", err)
    }
    defer tx.Rollback()

    q := db.User(tx)

    // Execute multiple queries in transaction
    _, err = q.CreateUser(ctx, "test1")
    if err != nil {
        t.Fatalf("Failed to create user 1: %v", err)
    }

    _, err = q.CreateUser(ctx, "test2")
    if err != nil {
        t.Fatalf("Failed to create user 2: %v", err)
    }

    // Commit transaction
    if err := tx.Commit(); err != nil {
        t.Fatalf("Failed to commit transaction: %v", err)
    }
}
```

### 9. Benchmarks

```go
// benchmark_test.go
package db_test

import (
    "testing"
    "myproject/testdata/db"
)

func BenchmarkQuery(b *testing.B) {
    ctx := context.Background()
    db, err := sqlc.New(testConfig, sqlc.NewQuerier(testConfig))
    if err != nil {
        b.Fatalf("Failed to connect: %v", err)
    }
    defer db.Close()

    q := db.User(ctx)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := q.ListUsers(ctx)
        if err != nil {
            b.Fatalf("Query failed: %v", err)
        }
    }
    b.StopTimer()
}
```

## Pros

- ✅ Minimal dependencies (database/sql only)
- ✅ No database server needed (SQLite file-based)
- ✅ Easy to set up and tear down
- ✅ Test database paths (testdata/)
- ✅ No complex features (simple tests)
- ✅ Fast build times
- ✅ Simple generated code

## Cons

- ❌ No UUID support (tests use simple INTEGER IDs)
- ❌ No JSON support (tests use simple types)
- ❌ No prepared queries
- ❌ No interface generation
- ❌ SQLite not production-ready for high scale

## When to Use

- ✅ Writing test fixtures
- ✅ Creating mock data
- ✅ Integration tests
- ✅ Test databases (isolate from production)
- ✅ Test-first development
- ✅ Quick prototype testing
- ✅ Unit tests for generated code
- ✅ Performance benchmarks

## When NOT to Use

- ❌ Production systems (use Enterprise template)
- ❌ API services (use Microservice template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)
- ❌ Real user data (use other template)
- ❌ High-performance requirements (use Enterprise template)

## Test Database Management

### Clean Before Each Test

```bash
# Remove test database
rm -f testdata/test.db

# Run tests
go test ./...

# Test database will be recreated
```

### Use Test Isolation

```bash
# Each test gets its own database
export TEST_DB="testdata/test_$(date +%s).db"

# Or use -run flag for parallel tests
go test -parallel 4
```

### Load Test Data

```bash
# Load test fixtures before tests
sqlite3 testdata/test.db < testdata/fixtures/test_data.sql

# Or in Go tests
func TestMain(m *testing.M) {
    // Load test fixtures
    db, _ := sqlc.New(testConfig)
    defer db.Close()

    // Load test data...
    tx, _ := db.Begin(context.Background())
    // ... load fixtures ...
    tx.Commit()

    // Run tests
    m.Run()
}
```

### Cleanup After Tests

```bash
# Remove test database
rm -f testdata/test.db

# Clean test output
rm -f *.test
```

## Best Practices for Testing

1. **Isolation** → Each test should have its own test database
2. **Fixtures** → Use consistent test data across test runs
3. **Mocking** → Mock database dependencies for unit tests
4. **Cleanup** → Clean up test databases and files after tests
5. **Transactions** → Test transaction behavior (commit/rollback)
6. **Timeouts** → Set timeouts on test database operations
7. **Assertions** → Use test assertions to verify generated code behavior
8. **Coverage** → Aim for 100% test coverage of generated code
9. **Benchmarks** → Benchmark query performance with generated code
10. **Integration Tests** → Test full workflow with real database

---

**Last Updated:** 2026-02-05
