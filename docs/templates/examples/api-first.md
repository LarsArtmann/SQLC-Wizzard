# API First Template Example

This is an API-first development example suitable for REST/GraphQL APIs with JSON serialization optimization.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by APIFirstTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
```

## Characteristics

- **Database:** PostgreSQL with `pgx/v5` driver
- **Driver:** `pgx/v5` (high performance)
- **Features:** JSON tags, enum validation, camelCase naming
- **Output:** `internal/db/` directory
- **Naming:** CamelCase field names (JSON API standard)

## Usage

### 1. Initialize Project

```bash
sqlc-wizard init --template api-first
```

### 2. Generate Go Code

```bash
sqlc generate
```

### 3. Use Generated Code

```go
package main

import (
    "context"
    "encoding/json"
    "myproject/internal/db"
)

type User struct {
    ID        uuid.UUID      `json:"id"`
    Name       string         `json:"name"`
    Email      string         `json:"email"`
    Profile   json.RawMessage `json:"profile"`  // JSONB support
    Role       string         `json:"role"`
    Status     Status         `json:"status"`     // Enum type
}

type Status string

const (
    StatusActive Status = "active"
    StatusInactive Status = "inactive"
    StatusPending Status = "pending"
)

// Generated Query Interface
type Querier interface {
    User(ctx context.Context) *UserQueries
    CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error)
    GetUser(ctx context.Context, id uuid.UUID) (*User, error)
    GetUserByEmail(ctx context.Context, email string) (*User, error)
    ListUsers(ctx context.Context) ([]*User, error)
    UpdateUser(ctx context.Context, arg UpdateUserParams) error
    DeleteUser(ctx context.Context, id uuid.UUID) error
}

// Generated Enum Validation Method
func (User) Valid() error {
    switch s.Status {
    case StatusActive, StatusInactive, StatusPending:
        return nil
    default:
        return fmt.Errorf("invalid status: %s", s.Status)
    }
}

func main() {
    ctx := context.Background()
    db, err := sqlc.New(config, sqlc.NewQuerier(config))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    q := db.User(ctx)

    // Create user
    userID, err := q.CreateUser(ctx, CreateUserParams{
        Name:  "John Doe",
        Email: "john@example.com",
    })
    if err != nil {
        log.Fatal(err)
    }

    // Get user by ID
    user, err := q.GetUser(ctx, userID)
    if err != nil {
        log.Fatal(err)
    }

    // JSON marshaling (API response)
    resp := map[string]interface{}{
        "user": map[string]interface{}{
            "id": user.ID,
            "name": user.Name,
            "email": user.Email,
            "profile": user.Profile,  // JSON.RawMessage marshals to {}
        },
    }

    jsonBytes, _ := json.Marshal(resp)
    fmt.Printf("API Response: %s\n", string(jsonBytes))
}
```

## Example Schema

Create `internal/db/schema/01_users.sql`:

```sql
-- name: User
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    profile JSONB,              -- JSON document storage
    role TEXT NOT NULL DEFAULT 'user',
    status TEXT NOT NULL DEFAULT 'pending',  -- Enum field
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## Example Query

Create `internal/db/queries/01_users.sql`:

```sql
-- name: CreateUser
-- Insert a new user
INSERT INTO users (name, email, profile)
VALUES ($1, $2, $3)
RETURNING id;

-- name: GetUser
-- Get user by ID
SELECT * FROM users
WHERE id = $1;

-- name: ListActiveUsers
-- List only active users
SELECT * FROM users
WHERE status = 'active'
ORDER BY created_at DESC;
```

## Pros

- ✅ High-performance PostgreSQL driver (pgx/v5)
- ✅ JSON tags with camelCase (API standard)
- ✅ Enum validation (type safety)
- ✅ All enum values generated
- ✅ Prepared queries (security & performance)
- ✅ Interface generation (mocking & testing)
- ✅ JSONB support (document storage)
- ✅ Pointer types on result & params structs
- ✅ Optimized for API responses

## Cons

- ❌ No UUID support (use Enterprise if needed)
- ❌ No array support (use Enterprise if needed)
- ❌ No full-text search (use Analytics template)

## When to Use

- ✅ Building REST APIs
- ✅ Building GraphQL APIs
- ✅ API-first development methodology
- ✅ Services with JSON serialization requirements
- ✅ Projects needing camelCase field names
- ✅ Projects requiring enum validation

## When NOT to Use

- ❌ Analytics platforms (use Analytics template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)
- ❌ Hobby projects (use Hobby template)
- ❌ Systems requiring full-text search (use Analytics template)

## Environment Setup

Set `DATABASE_URL` environment variable:

```bash
# Local development
export DATABASE_URL="postgres://user:password@localhost:5432/myapi"

# Using Docker
export DATABASE_URL="postgres://user:password@api-db:5432/myapi"

# In production (from secret)
export DATABASE_URL="${API_DATABASE_SECRET}"
```

## Best Practices

1. **JSON Serialization** → Use camelCase tags for API responses
2. **Enum Validation** → Leverage generated Valid() methods
3. **API Versioning** → Include version in JSON responses
4. **Error Handling** → Return structured error objects in JSON
5. **API Documentation** → Document all JSON schemas and enum values

---

**Last Updated:** 2026-02-05
