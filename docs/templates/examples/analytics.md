# Analytics Template Example

This is an analytics-optimized example suitable for data warehousing and reporting platforms.

## Generated Configuration

```yaml
# sqlc.yaml - Generated by AnalyticsTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/analytics/queries
    schema: internal/analytics/schema
    database:
      uri: ${ANALYTICS_DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: analytics
        out: internal/analytics
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_interface: true
        emit_empty_slices: true
        json_tags_case_style: snake
        overrides:
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: "[]string"
            nullable: true
          - db_type: tsvector
            go_type: string
            go_import_path: ""
        rename:
          id: ID
          json: JSON
          api: API
          http: HTTP
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
```

## Characteristics

- **Database:** PostgreSQL with `pgx/v5` driver
- **Driver:** `pgx/v5` (high performance PostgreSQL)
- **Features:** Array support (time-series), JSONB (document storage), Full-Text search (analytics)
- **Output:** `internal/analytics/` directory

## Usage

### 1. Initialize Project

```bash
sqlc-wizard init --template analytics
```

### 2. Generate Go Code

```bash
sqlc generate
```

### 3. Use Generated Code

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "myproject/internal/analytics"
)

type Event struct {
    ID        uuid.UUID      `json:"id"`
    Timestamp time.Time       `json:"timestamp"`
    Data      json.RawMessage `json:"data"`    // JSONB for flexible data
    Tags      []string        `json:"tags"`       // Array for time-series
    Search    *string         `json:"searchText"`  // Full-text search result
}

func main() {
    ctx := context.Background()
    db, err := sqlc.New(config, sqlc.NewQuerier(config))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    q := db.Event(ctx)

    // Insert time-series event
    _, err = q.InsertEvent(ctx, Event{
        Timestamp: time.Now(),
        Data: json.RawMessage(`{"type":"pageview","page":"/home"}`),
        Tags: []string{"pageview", "home"},
    })
    if err != nil {
        log.Fatal(err)
    }

    // Full-text search
    events, err := q.SearchEvents(ctx, "%home%")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found %d events\n", len(events))
}
```

## Example Schema

Create `internal/analytics/schema/01_events.sql`:

```sql
-- name: Event
-- Time-series event table with JSONB, arrays, full-text search
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    data JSONB,                          -- Flexible document storage
    tags TEXT[] NOT NULL,                 -- Array for time-series
    search_text TSVECTOR,                -- Full-text search
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for full-text search
CREATE INDEX idx_events_search_text ON events USING GIN (search_text);

-- Index for time-series queries
CREATE INDEX idx_events_timestamp ON events(timestamp);
```

## Example Query

Create `internal/analytics/queries/01_events.sql`:

```sql
-- name: InsertEvent
-- Insert time-series event
INSERT INTO events (timestamp, data, tags)
VALUES ($1, $2, $3);

-- name: SearchEvents
-- Full-text search on events
SELECT *, ts_rank(search_text, websearch_to_tsquery('english', $1)) AS rank
FROM events
WHERE search_text @@ websearch_to_tsquery('english', $1)
ORDER BY rank DESC
LIMIT ALL($2);
```

## Pros

- ✅ Array support (time-series data)
- ✅ JSONB support (flexible document storage)
- ✅ Full-text search (analytics queries)
- ✅ pgx/v5 driver (high performance)
- ✅ Strict validation (data quality)
- ✅ Optimized for analytics workloads

## Cons

- ❌ No UUID support (time-series data may use other IDs)
- ❌ No prepared queries (analytics may need flexibility)
- ❌ More complex than simple CRUD

## When to Use

- ✅ Data analytics platforms
- ✅ Warehousing solutions
- ✅ Reporting systems
- ✅ Time-series data
- ✅ Full-text search requirements
- ✅ Complex data relationships

## When NOT to Use

- ❌ Simple CRUD apps (use Hobby/Microservice templates)
- ❌ API services (use API First template)
- ❌ Multi-tenant SaaS (use Multi-Tenant template)
- ❌ Hobby projects (use Hobby template)

---

**Last Updated:** 2026-02-05
