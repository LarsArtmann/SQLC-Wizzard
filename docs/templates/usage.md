# Template Usage Guide

This guide helps you choose the right template for your project and provides usage examples.

---

## Overview

SQLC-Wizard provides **8 pre-configured templates** optimized for different use cases. Each template generates a complete `sqlc.yaml` configuration with appropriate database settings, Go code generation options, and validation rules.

---

## Quick Template Reference

| Template         | Best For                             | Database   | Complexity                                         | Features |
| ---------------- | ------------------------------------ | ---------- | -------------------------------------------------- | -------- |
| **Hobby**        | Personal projects, small apps        | SQLite     | Simple, minimal dependencies                       |
| **Microservice** | API services, REST/GraphQL           | PostgreSQL | Prepared queries, JSON tags, interfaces            |
| **Enterprise**   | Production systems, critical apps    | PostgreSQL | Strict validation, UUIDs, JSONB, arrays, full-text |
| **API First**    | REST/GraphQL APIs (API-first design) | PostgreSQL | JSON support, camelCase naming, prepared queries   |
| **Analytics**    | Data analytics, warehousing          | PostgreSQL | Arrays, full-text search, JSON support             |
| **Testing**      | Test fixtures, mock data             | SQLite     | Minimal features, testdb path                      |
| **Multi Tenant** | SaaS platforms, multi-tenant apps    | PostgreSQL | Tenant isolation, UUIDs, arrays, JSON support      |
| **Library**      | Reusable Go libraries                | PostgreSQL | Minimal dependencies, JSON tags, interfaces        |

---

## Detailed Template Guide

### 1. Hobby Template

**Best For:** Personal projects, small applications, prototypes

**Description:** Simple, lightweight configuration for hobby projects and personal use cases.

**Database Default:** SQLite (file:dev.db)

**Key Features:**

- Minimal Go dependencies
- Simple `database/sql` driver
- No UUID, JSON, or array support
- Relaxed validation (no strict checks)
- Easy to get started

**When to Use:**

- Building personal apps
- Learning sqlc
- Quick prototypes
- Projects with simple data models

**When NOT to Use:**

- Production systems
- Multi-user applications
- Complex data relationships
- High-performance requirements

**Usage Example:**

```yaml
# Automatically generated by HobbyTemplate
version: "2"
sql:
  - engine: sqlite
    queries: db/queries
    schema: db/schema
    database:
      uri: file:dev.db
    gen:
      go:
        package: db
        out: db
        sql_package: database/sql
        emit_json_tags: false
        emit_prepared_queries: false
        emit_interface: false
        emit_empty_slices: true
        json_tags_case_style: snake
```

**Go Generated Code Characteristics:**

- Uses `database/sql` package
- No custom imports for UUID/JSON
- Basic Go types (no UUID, no RawMessage)
- No validation methods on generated code

---

### 2. Microservice Template

**Best For:** API services, microservices, REST/GraphQL backends

**Description:** Production-ready configuration for API services and microservices with prepared queries and JSON support.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver (high performance)
- Prepared queries (security & performance)
- JSON tag support (API responses)
- Interface generation (mocking & testing)
- No strict validation (flexible)
- Internal package structure (`internal/db`)

**When to Use:**

- Building REST APIs
- Building GraphQL APIs
- Microservice architecture
- API-first development
- Production APIs

**When NOT to Use:**

- Analytics platforms (use Analytics template)
- SaaS platforms (use Multi-Tenant template)
- Simple single-file apps (use Hobby template)

**Usage Example:**

```yaml
# Automatically generated by MicroserviceTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: false
        emit_params_struct_pointers: false
        json_tags_case_style: camel
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package (high-performance PostgreSQL driver)
- Prepared query methods (`Query(ctx, ...)`)
- Interface generation (`Querier` interface)
- JSON tags on structs (`json:"fieldName"`)
- CamelCase field names for JSON serialization
- Easy to mock with interfaces

---

### 3. Enterprise Template

**Best For:** Production systems, enterprise applications, critical infrastructure

**Description:** Strict, production-ready configuration with comprehensive validation, type safety, and advanced database features.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver
- UUID support (for primary keys)
- JSONB support (for document storage)
- Array support (for many-to-many relationships)
- Full-text search support (for search)
- Strict validation (fail-fast on issues)
- All safety rules enabled (no SELECT \*, no DROP TABLE, etc.)
- Interface generation
- Internal package structure (`internal/db`)

**When to Use:**

- Production applications
- Enterprise systems
- Critical infrastructure
- Systems with strict data integrity requirements
- Compliance-heavy environments

**When NOT to Use:**

- Personal projects (use Hobby template)
- Simple prototypes (use Hobby template)
- Analytics platforms (use Analytics template)
- Multi-tenant SaaS (use Multi-Tenant template)

**Usage Example:**

```yaml
# Automatically generated by EnterpriseTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: "[]string"
            nullable: true
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
          - name: require-where
            rule: WHERE clause is required
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package (high-performance PostgreSQL driver)
- UUID types for primary keys (`uuid.UUID`)
- JSON types for document storage (`json.RawMessage`)
- Array types for relationships (`[]string`)
- Prepared query methods
- Interface generation
- Pointer types on result structs (`*User`)
- Pointer types on params structs (`*GetUserParams`)
- All safety rules enforced
- CamelCase field names with JSON tags

---

### 4. API First Template

**Best For:** REST/GraphQL APIs with API-first design methodology

**Description:** Configuration optimized for API-first development with JSON serialization, camelCase naming, and prepared queries.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver
- JSON tag support (essential for APIs)
- CamelCase JSON field names (API standard)
- Prepared queries (performance & security)
- Interface generation
- No strict validation (flexible for API evolution)
- Internal package structure (`internal/db`)

**When to Use:**

- Building REST APIs
- Building GraphQL APIs
- API-first development methodology
- Services with JSON serialization requirements
- Projects needing camelCase field names

**When NOT to Use:**

- Analytics platforms (use Analytics template)
- Multi-tenant SaaS (use Multi-Tenant template)
- Hobby projects (use Hobby template)

**Usage Example:**

```yaml
# Automatically generated by APIFirstTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
        emit_params_struct_pointers: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: "[]string"
            nullable: true
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
          otp: OTP
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package
- JSON tags with camelCase naming (`json:"fieldName"`)
- Enum validation methods
- Pointer types on result & params structs
- Prepared query methods
- Interface generation
- API-optimized field names (camelCase)

---

### 5. Analytics Template

**Best For:** Data analytics, warehousing, reporting platforms

**Description:** Configuration optimized for analytics workloads with array support, full-text search, and JSON document storage.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver
- Array support (for time-series data)
- JSONB support (for document storage)
- Full-text search support (for analytics queries)
- Interface generation
- Strict validation (ensures data quality)
- Internal package structure (`internal/analytics`)

**When to Use:**

- Data analytics platforms
- Warehousing solutions
- Reporting systems
- Time-series data
- Full-text search requirements
- Complex data relationships (arrays)

**When NOT to Use:**

- Simple CRUD apps (use Hobby/Microservice templates)
- API services (use API First template)
- Multi-tenant SaaS (use Multi-Tenant template)

**Usage Example:**

```yaml
# Automatically generated by AnalyticsTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/analytics/queries
    schema: internal/analytics/schema
    database:
      uri: ${ANALYTICS_DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: analytics
        out: internal/analytics
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_interface: true
        emit_empty_slices: true
        json_tags_case_style: snake
        overrides:
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: "[]string"
            nullable: true
          - db_type: tsvector
            go_type: string
            go_import_path: ""
        rename:
          id: ID
          json: JSON
          api: API
          http: HTTP
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package
- Array types (`[]string`) for time-series data
- JSONB types (`json.RawMessage`) for document storage
- Full-text search types (`tsvector`)
- Strict validation enabled
- Interface generation
- SnakeCase field names (analytics standard)

---

### 6. Testing Template

**Best For:** Test fixtures, mock data, test databases

**Description:** Minimal configuration for testing and development with test database paths.

**Database Default:** SQLite (file:testdata/test.db)

**Key Features:**

- Minimal Go dependencies
- Simple `database/sql` driver
- Test database paths (`testdata/test.db`)
- No advanced features (UUID, JSON, arrays)
- No strict validation (flexible for tests)
- Easy to set up and tear down

**When to Use:**

- Writing test fixtures
- Creating mock data
- Integration tests
- Test databases
- Test-first development

**When NOT to Use:**

- Production systems (use Enterprise template)
- API services (use Microservice template)
- Multi-tenant SaaS (use Multi-Tenant template)

**Usage Example:**

```yaml
# Automatically generated by TestingTemplate
version: "2"
sql:
  - engine: sqlite
    queries: testdata/db/queries
    schema: testdata/db/schema
    database:
      uri: file:testdata/test.db
    strict_function_checks: false
    strict_order_by: false
    gen:
      go:
        package: testdata/db
        out: testdata/db
        sql_package: database/sql
        emit_json_tags: false
        emit_prepared_queries: false
        emit_interface: false
        emit_empty_slices: true
        json_tags_case_style: snake
```

**Go Generated Code Characteristics:**

- Uses `database/sql` package
- Test database paths (`testdata/`)
- No advanced types or features
- No validation
- Simple, easy to use for tests

---

### 7. Multi Tenant Template

**Best For:** SaaS platforms, multi-tenant applications, B2B systems

**Description:** Configuration optimized for multi-tenant applications with UUID support for tenant isolation and comprehensive feature support.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver
- UUID support (for tenant IDs)
- JSONB support (for tenant metadata)
- Array support (for tenant relationships)
- Interface generation
- Strict validation (ensures tenant data integrity)
- Internal package structure (`internal/db`)

**When to Use:**

- SaaS platforms
- Multi-tenant applications
- B2B systems
- Applications requiring tenant isolation
- User-per-organization models

**When NOT to Use:**

- Single-tenant apps (use Hobby/Microservice templates)
- Analytics platforms (use Analytics template)
- Hobby projects (use Hobby template)

**Usage Example:**

```yaml
# Automatically generated by MultiTenantTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    strict_function_checks: true
    strict_order_by: true
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: true
        emit_empty_slices: true
        json_tags_case_style: camel
        overrides:
          - db_type: uuid
            go_type: UUID
            go_import_path: github.com/google/uuid
          - db_type: jsonb
            go_type: RawMessage
            go_import_path: encoding/json
          - db_type: _text
            go_type: "[]string"
            nullable: true
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
        rules:
          - name: no-select-star
            rule: SELECT * is not allowed
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package
- UUID types for tenant IDs (`uuid.UUID`)
- JSONB types for tenant metadata (`json.RawMessage`)
- Array types for tenant relationships (`[]string`)
- Strict validation enabled
- Interface generation
- CamelCase field names with JSON tags
- Optimized for multi-tenant queries

---

### 8. Library Template

**Best For:** Reusable Go libraries, SDKs, packages

**Description:** Minimal, flexible configuration for reusable libraries with broad compatibility and minimal dependencies.

**Database Default:** PostgreSQL (pgx/v5)

**Key Features:**

- PostgreSQL with `pgx/v5` driver
- JSON tag support (library consumers)
- Interface generation (flexibility for library users)
- Enum validation methods (type safety)
- No strict validation (flexible for library consumers)
- Internal package structure (`internal/db`)

**When to Use:**

- Creating reusable Go libraries
- Building SDKs
- Developing shared packages
- Publishing npm/go modules
- Projects requiring interface flexibility

**When NOT to Use:**

- Full applications (use Hobby/Microservice templates)
- Production systems with strict requirements (use Enterprise template)
- Multi-tenant SaaS (use Multi-Tenant template)
- Analytics platforms (use Analytics template)

**Usage Example:**

```yaml
# Automatically generated by LibraryTemplate
version: "2"
sql:
  - engine: postgresql
    queries: internal/db/queries
    schema: internal/db/schema
    database:
      uri: ${DATABASE_URL}
    gen:
      go:
        package: db
        out: internal/db
        sql_package: pgx/v5
        build_tags: postgres,pgx
        emit_json_tags: true
        emit_interface: true
        emit_empty_slices: true
        emit_enum_valid_method: true
        emit_all_enum_values: true
        json_tags_case_style: camel
        rename:
          id: ID
          uuid: UUID
          url: URL
          uri: URI
          json: JSON
          api: API
          http: HTTP
          db: DB
          otp: OTP
```

**Go Generated Code Characteristics:**

- Uses `pgx/v5` package
- JSON tags for library consumers
- Interface generation (library users can mock)
- Enum validation methods (type safety)
- Pointer types on result & params structs
- CamelCase field names with JSON tags
- Optimized for library usage (flexible but type-safe)

---

## Template Comparison Matrix

See [Template Comparison Matrix](./comparison.md) for detailed feature comparison.

---

## How to Choose a Template

### Decision Tree

1. **Is this a production/enterprise system?**
   - **YES** → Enterprise Template
   - **NO** → Continue to 2

2. **Is this a SaaS/multi-tenant application?**
   - **YES** → Multi-Tenant Template
   - **NO** → Continue to 3

3. **Is this an API-first project?**
   - **YES** → API First Template
   - **NO** → Continue to 4

4. **Is this for analytics/reporting?**
   - **YES** → Analytics Template
   - **NO** → Continue to 5

5. **Is this a reusable library/SDK?**
   - **YES** → Library Template
   - **NO** → Continue to 6

6. **Is this a test environment?**
   - **YES** → Testing Template
   - **NO** → Continue to 7

7. **Is this a microservice/API service?**
   - **YES** → Microservice Template
   - **NO** → Continue to 8

8. **Is this a personal/hobby project?**
   - **YES** → Hobby Template
   - **NO** → ERROR: No template matches

### Quick Reference

- **Simple & Fast** → Hobby, Testing
- **API Focused** → Microservice, API First
- **Data Heavy** → Analytics
- **User Focused** → Multi Tenant
- **Library Focused** → Library
- **Production Ready** → Enterprise

---

## Customization Guide

All templates support customization through `TemplateData`:

### Changing Database

```go
data.Database.Engine = templates.DatabaseTypeMySQL
```

### Enabling Features

```go
data.Database.UseUUIDs = true
data.Database.UseJSON = true
data.Database.UseArrays = true
```

### Adjusting Output Paths

```go
data.Output.BaseDir = "custom/path"
data.Output.QueriesDir = "custom/queries"
data.Output.SchemaDir = "custom/schema"
```

### Changing Package

```go
data.Package.Name = "custompackage"
data.Package.Path = "github.com/your/repo/custompackage"
```

See [Template Customization Guide](./customization.md) for more details.

---

## Common Patterns

### Pattern 1: Switching Databases

All templates support PostgreSQL, MySQL, and SQLite. Switch databases by changing the engine type:

```go
// Hobby template with PostgreSQL
hobbyTemplate := templates.NewHobbyTemplate()
data := hobbyTemplate.DefaultData()
data.Database.Engine = templates.DatabaseTypePostgreSQL
```

### Pattern 2: Mixing Templates

You can start with one template and customize settings from another:

```go
// Start with Hobby template
data := templates.NewHobbyTemplate().DefaultData()

// Add Enterprise features
data.Database.UseUUIDs = true
data.Database.UseJSON = true
data.Database.UseArrays = true
data.Validation.StrictFunctions = true
data.Validation.StrictOrderBy = true
```

### Pattern 3: Environment-Specific Configuration

Use environment variables for database URLs and sensitive data:

```yaml
database:
  uri: ${DATABASE_URL} # Set from environment
```

---

## Troubleshooting

### Issue: Generated code doesn't compile

**Solution:** Check that your Go version matches sqlc requirements (Go 1.18+)

### Issue: Can't find generated types

**Solution:** Ensure the `out` path matches your Go module path

### Issue: Database connection errors

**Solution:** Check that `DATABASE_URL` is set and accessible

### Issue: Type mismatches

**Solution:** Verify the `sql_package` setting matches your database driver

### Issue: Missing imports

**Solution:** sqlc will add imports automatically; ensure your code references them

---

## Best Practices

1. **Start simple** → Begin with Hobby or Testing template, then upgrade
2. **Version control** → Commit generated `sqlc.yaml` files
3. **Environment variables** → Use them for database URLs and secrets
4. **Test generated code** → Write tests for your generated code
5. **Document customizations** → Keep track of template modifications
6. **Review generated code** → Understand what sqlc generates
7. **Leverage templates** → Don't start from scratch; customize templates instead
8. **Stay consistent** → Use the same template pattern across your project

---

## Next Steps

1. Review the [Template Comparison Matrix](./comparison.md) for feature details
2. Choose a template based on your use case
3. Run the wizard: `sqlc-wizard init --template <template-name>`
4. Customize as needed (see [Template Customization Guide](./customization.md))
5. Generate your Go code: `sqlc generate`
6. Write tests for the generated code
7. Build and run your application

---

## Additional Resources

- [sqlc Documentation](https://docs.sqlc.dev/)
- [Template Comparison Matrix](./comparison.md)
- [Template Customization Guide](./customization.md)
- [Example Projects](../examples/)

---

**Last Updated:** 2026-02-05
