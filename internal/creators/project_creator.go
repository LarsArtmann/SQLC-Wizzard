package creators

import (
	"context"
	"fmt"

	"github.com/LarsArtmann/SQLC-Wizzard/generated"
	"github.com/LarsArtmann/SQLC-Wizzard/internal/adapters"
	"github.com/LarsArtmann/SQLC-Wizzard/pkg/config"
)

// CreateConfig contains configuration for project creation
type CreateConfig struct {
	ProjectName     string
	ProjectType     generated.ProjectType
	Database        generated.DatabaseType
	TemplateData    generated.TemplateData
	Config          *config.SqlcConfig
	IncludeAuth     bool
	IncludeFrontend bool
	Force           bool
}

// ProjectCreator handles creating complete project structures
type ProjectCreator struct {
	fs  adapters.FileSystemAdapter
	cli adapters.CLIAdapter
}

// NewProjectCreator creates a new project creator
func NewProjectCreator(fs adapters.FileSystemAdapter, cli adapters.CLIAdapter) *ProjectCreator {
	return &ProjectCreator{
		fs:  fs,
		cli: cli,
	}
}

// CreateProject creates a complete project structure
func (pc *ProjectCreator) CreateProject(ctx context.Context, config *CreateConfig) error {
	pc.cli.Println("üèóÔ∏è  Creating project structure...")

	// Create directory structure
	if err := pc.createDirectoryStructure(ctx, config); err != nil {
		return fmt.Errorf("failed to create directory structure: %w", err)
	}

	// Generate sqlc.yaml
	if err := pc.generateSQLCConfig(ctx, config); err != nil {
		return fmt.Errorf("failed to generate sqlc.yaml: %w", err)
	}

	// Generate database schema
	if err := pc.generateDatabaseSchema(ctx, config); err != nil {
		return fmt.Errorf("failed to generate database schema: %w", err)
	}

	// TODO: Full project scaffolding is not yet implemented
	// See GitHub issues for roadmap:
	// - Database schema generation
	// - Query file generation
	// - Migration file generation
	// - Go module structure
	// - Docker configuration
	// - Makefile generation
	// - Development scripts
	// - README generation
	// - Project-specific files
	//
	// For now, ProjectCreator only generates:
	// 1. Directory structure
	// 2. sqlc.yaml configuration file
	//
	// Additional scaffolding will be added based on user feedback and demand.

	return nil
}

// createDirectoryStructure creates the basic directory structure
func (pc *ProjectCreator) createDirectoryStructure(ctx context.Context, config *CreateConfig) error {
	pc.cli.Println("üìÅ Creating directory structure...")

	dirs := []string{
		"db/schema",
		"db/migrations",
		"internal/db",
		"internal/db/queries",
		"cmd/server",
		"pkg/config",
		"scripts",
		"test",
		"docs",
	}

	// Add project-specific directories based on project type
	// Note: Some project types may not be in generated types yet
	switch config.ProjectType {
	case generated.ProjectTypeMicroservice:
		dirs = append(dirs, "api", "internal/api", "internal/handlers")
		// TODO: Add other project types when generated types are complete
		// case generated.ProjectTypeFullstack:
		// 	dirs = append(dirs, "web", "web/src", "web/public", "internal/api")
		// case generated.ProjectTypeAPIFirst:
		// 	dirs = append(dirs, "api", "internal/api", "internal/handlers")
		// case generated.ProjectTypeLibrary:
		// 	dirs = append(dirs, "examples", "internal/testutil")
	}

	for _, dir := range dirs {
		if err := pc.fs.MkdirAll(ctx, dir, 0o755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// generateSQLCConfig generates the sqlc.yaml file
func (pc *ProjectCreator) generateSQLCConfig(ctx context.Context, cfg *CreateConfig) error {
	pc.cli.Println("‚öôÔ∏è  Generating sqlc.yaml...")

	// Defensive check: ensure config is not nil before marshalling
	if cfg.Config == nil {
		return fmt.Errorf("sqlc config is nil: cannot marshal empty configuration to yaml")
	}

	// Convert config to YAML using the marshaller
	yamlContent, err := config.Marshal(cfg.Config)
	if err != nil {
		return fmt.Errorf("failed to convert config to YAML: %w", err)
	}

	return pc.fs.WriteFile(ctx, "sqlc.yaml", yamlContent, 0o644)
}

// generateDatabaseSchema creates database schema file
func (pc *ProjectCreator) generateDatabaseSchema(ctx context.Context, cfg *CreateConfig) error {
	pc.cli.Println("üóÑÔ∏è  Generating database schema...")

	// Build schema content based on project configuration
	schemaContent := pc.buildSchemaSQL(cfg.TemplateData)

	return pc.fs.WriteFile(ctx, "schema.sql", []byte(schemaContent), 0o644)
}

// buildSchemaSQL creates SQL schema content
func (pc *ProjectCreator) buildSchemaSQL(data generated.TemplateData) string {
	schema := "-- Database schema for " + data.ProjectName + "\n"
	schema += "-- Generated by SQLC-Wizard\n\n"

	// Basic user table (common in most projects)
	schema += pc.createUserTable(data)

	// Add project-specific tables based on project type
	switch data.ProjectType {
	case generated.ProjectTypeMicroservice:
		schema += pc.createMicroserviceTables(data)
	case generated.ProjectTypeEnterprise:
		schema += pc.createEnterpriseTables(data)
	case generated.ProjectTypeAPIFirst:
		schema += pc.createAPIFirstTables(data)
		// Note: Add more project types as needed
	}

	schema += "\n-- Indexes for performance\n"
	schema += pc.createBasicIndexes(data)

	return schema
}

// createUserTable creates users table
func (pc *ProjectCreator) createUserTable(data generated.TemplateData) string {
	return `
-- Users table for authentication and user management
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add basic indexes for users
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
`
}

// createMicroserviceTables creates tables for microservice projects
func (pc *ProjectCreator) createMicroserviceTables(data generated.TemplateData) string {
	return `
-- API tokens table for microservice authentication
CREATE TABLE api_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_api_tokens_user FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_api_tokens_user_id ON api_tokens(user_id);
CREATE INDEX idx_api_tokens_expires_at ON api_tokens(expires_at);
`
}

// createEnterpriseTables creates tables for enterprise projects
func (pc *ProjectCreator) createEnterpriseTables(data generated.TemplateData) string {
	return `
-- Audit log table for enterprise compliance
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100) NOT NULL,
    resource_id VARCHAR(255),
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_audit_logs_user FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
`
}

// createAPIFirstTables creates tables for API-first projects
func (pc *ProjectCreator) createAPIFirstTables(data generated.TemplateData) string {
	return `
-- Rate limiting table for API-first projects
CREATE TABLE rate_limits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_identifier VARCHAR(255) NOT NULL,
    endpoint VARCHAR(255) NOT NULL,
    max_requests INTEGER NOT NULL DEFAULT 100,
    window_seconds INTEGER NOT NULL DEFAULT 60,
    current_requests INTEGER DEFAULT 0,
    window_start TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(client_identifier, endpoint)
);

CREATE INDEX idx_rate_limits_client ON rate_limits(client_identifier);
CREATE INDEX idx_rate_limits_window ON rate_limits(window_start);
`
}

// createBasicIndexes creates basic performance indexes
func (pc *ProjectCreator) createBasicIndexes(data generated.TemplateData) string {
	return `
-- Basic performance indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_created_at ON users(created_at);
`
}

// NOTE: Additional scaffolding methods will be implemented based on demand
// See the TODO in CreateProject for planned features
